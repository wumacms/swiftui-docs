# SwiftUI框架核心：声明式设计与数据驱动思想

## 第1章 声明式语法基础
1.1_描述“什么”而非“如何”
1.2_与命令式UI（UIKit）的对比
1.3_代码可读性与简洁性优势
1.4_UI即状态的函数

## 第2章 视图作为值类型
2.1_视图是轻量级结构体（Struct）
2.2_视图的创建与销毁成本低
2.3_避免复杂的视图层级和引用循环
2.4_值语义对UI一致性的保障

## 第3章 单一数据源（Single Source of Truth）
3.1_数据是驱动UI更新的唯一来源
3.2_避免UI状态不一致问题
3.3_简化状态管理逻辑
3.4_数据流的单向性原则

## 第4章 状态管理属性包装器
4.1_@State：管理本地简单值类型状态
4.2_@Binding：创建双向数据绑定
4.3_@StateObject：管理引用类型对象的生命周期
4.4_@ObservedObject：订阅外部对象的更新
4.5_@EnvironmentObject：在视图层级中共享数据
4.6_@Environment：读取系统环境值

## 第5章 UI自动更新机制
5.1_状态变化如何触发视图重绘
5.2_视图依赖关系图的构建
5.3_最小化视图更新范围的策略
5.4_数据流的可预测性

## 第6章 组合优于继承
6.1_通过组合小视图构建复杂界面
6.2_视图的可复用性设计
6.3_避免深度继承带来的复杂性
6.4_函数式构建UI的实践

## 第7章 修饰符（Modifiers）的设计
7.1_修饰符返回一个新的视图
7.2_链式调用的实现原理
7.3_修饰符的顺序重要性
7.4_自定义修饰符的创建与使用

## 第8章 布局系统设计
8.1_容器视图（HStack, VStack, ZStack）
8.2_自适应布局与优先级
8.3_GeometryReader：获取父视图几何信息
8.4_布局中立性与跨平台适应

## 第9章 视图身份（Identity）
9.1_显式身份：id()修饰符的作用
9.2_结构性身份：基于视图在层级中的位置
9.3_身份对动画和过渡的影响
9.4_ForEach中身份的重要性

## 第10章 性能优化设计
10.1_视图差异比较（Diffing）算法
10.2_懒加载容器（Lazy Stacks & Grids）
10.3_减少不必要的视图重绘
10.4_将计算密集型任务移出视图主体

## 第11章 生命周期管理
11.1_视图生命周期与状态生命周期的区别
11.2_onAppear和onDisappear修饰符
11.3_@StateObject的生命周期管理
11.4_任务（Task）修饰符与异步操作

## 第12章 抽象与适配
12.1_一套代码，多平台运行
12.2_平台特定控件的抽象化
12.3_使用#if os()进行平台条件编译
12.4_控件的自适应行为

## 第13章 与原生框架的互操作性
13.1_UIViewRepresentable协议
13.2_UIViewControllerRepresentable协议
13.3_NSViewRepresentable协议
13.4_在SwiftUI中嵌入UIKit-AppKit组件