# 《SwiftUI封装与重构：构建可维护的UI》

## 第1章 识别并提取可复用视图
1.1_识别重复的视图代码块

1.2_使用`struct`创建新的自定义View

1.3_将提取的视图替换回原代码

1.4_为新视图提供描述性命名

## 第2章 通过属性传递数据
2.1_为组件定义`let`常量属性

2.2_在父视图中初始化并传递数据

2.3_使用`@State`管理组件内部状态

2.4_区分何时使用`let`与`@State`

## 第3章 使用`@Binding`实现双向数据流
3.1_理解`@Binding`的概念与用途

3.2_在子视图中声明`@Binding`属性

3.3_在父视图中通过`$`传递绑定

3.4_实现父子视图状态的实时同步

## 第4章 通过闭包处理组件事件
4.1_在组件中定义动作闭包属性

4.2_在组件内部的交互控件中调用闭包

4.3_父视图实现闭包以响应事件

4.4_传递无参数和带参数的闭包

## 第5章 自定义视图修饰符(ViewModifier)
5.1_创建符合`ViewModifier`协议的结构体

5.2_实现`body(content-)`方法

5.3_通过`modifier()`应用修饰符

5.4_使用`extension View`简化调用

## 第6章 利用泛型构建通用组件
6.1_为自定义View添加泛型参数

6.2_使用`where`子句约束泛型类型

6.3_构建通用列表行或容器视图

6.4_泛型在数据展示组件中的应用

## 第7章 使用`@ViewBuilder`构建灵活的容器
7.1_理解`@ViewBuilder`的作用

7.2_在初始化器或函数参数中使用

7.3_创建接受多个子视图的自定义容器

7.4_实现类似`VStack`或`HStack`的组件

## 第8章 封装环境对象(EnvironmentObject)
8.1_定义`ObservableObject`作为数据源

8.2_在视图层级高层注入环境对象

8.3_在子组件中使用`@EnvironmentObject`访问

8.4_环境对象在主题或账户管理中的应用

## 第9章 识别巨型视图(Massive View)
9.1_检查超过200行的`body`属性

9.2_识别嵌套层级过深的视图结构

9.3_评估视图是否承担过多职责

9.4_视图逻辑与UI描述混杂的迹象

## 第10章 识别混乱的状态管理
10.1_过度使用`@State`导致状态分散

10.2_不恰当的`@ObservedObject`刷新

10.3_数据源不明确（Source of Truth混乱）

10.4_`@Binding`链条过长难以追踪

## 第11章 识别不当的逻辑放置
11.1_在`body`中执行复杂的计算或数据转换

11.2_网络请求或数据库操作直接在View中触发

11.3_业务逻辑与视图代码紧密耦合

11.4_辅助函数(Helper)滥用

## 第12章 拆分巨型视图
12.1_按功能区域拆分为子视图

12.2_按逻辑分组提取计算属性视图

12.3_使用私有方法返回`some View`

12.4_应用前述的组件封装技术

## 第13章 重构状态管理：引入MVVM
13.1_创建`ViewModel`作为`ObservableObject`

13.2_将业务逻辑和状态从View迁移到ViewModel

13.3_在View中使用`@StateObject`或`@ObservedObject`

13.4_通过函数和`@Published`属性进行交互

## 第14章 优化数据流和依赖
14.1_使用`@EnvironmentObject`共享全局状态

14.2_将多个`@State`属性合并到单一结构体中

14.3_利用`Combine`处理复杂的数据流

14.4_通过服务层(Service Layer)抽象数据获取

## 第15章 精炼视图逻辑
15.1_将`if-else`或`switch`逻辑移入ViewModel

15.2_创建专门的格式化工具(Formatter)

15.3_使用`extension`为数据模型添加计算属性

15.4_将重复的UI配置封装到`ViewModifier`中