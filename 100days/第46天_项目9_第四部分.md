# 第46天 项目 9 第四部分

又一个项目完成了，到目前为止，你已经初步接触了SwiftUI几乎所有的导航API。你很可能想马上回到应用开发中，但请花点时间停下来回顾一下所学内容——也许在一段时间内你不会用到所有这些知识，但重要的是你至少要记住学过了什么，以便之后可以回头查阅。

所以，今天你还有一次复习来检验自己的记忆，另外还有一些挑战让你自己动手编码。和往常一样，这些挑战我不会提供解决方案，但这正是关键所在——正如美国国家橄榄球联盟（NFL）球员特洛伊·波拉马鲁曾经说过的：“我一直认为，没有人能比我自己更能挑战我。”

你可以用任何你喜欢的方式、在任何你方便的时间来解决这些挑战，也许你能毫无困难地完成。另一方面，或许在解决过程中，你会发现自己某些知识掌握得还不够扎实——只有尝试过，你才能知道问题所在。

今天你应该完成第9个项目的总结章节，完成相关复习，然后攻克所有三个挑战。

- 导航：总结
- 第9个项目复习：导航



## 导航：总结

*作者：Paul Hudson  2023年11月2日*

我希望这个技术项目能让你在SwiftUI导航方面更有信心，因为导航几乎是你将要构建的每一个应用的核心。

诚然，像`Hashable`这样的部分起初可能不是完全易懂，但目前你真正需要知道的是它是一项必需的协议——当我们使用结构体时，Swift可以为我们完成大部分工作，所以通常只需添加`Hashable`、`Codable`和`Equatable`这类协议就足够了。

之后我们会学习另一种更适合大屏幕设备的导航方式，但目前你已经完成了本部分的学习——做得很好！

## 回顾所学内容

任何人都能看完一个教程，但要记住所学的知识则需要实际付出努力。确保你能从这些教程中收获尽可能多的知识是我的职责，完成后面的练习题可以帮助你检验学习成果。

## 挑战

学习编程最好的方法之一就是尽可能多地自己编写代码，因此我准备了三个拓展本应用的方向，帮助你确保完全理解所学内容。

1. 修改第7个项目（iExpense），使其使用`NavigationLink`添加新支出项，而不是使用工作表（sheet）。（提示：`dismiss()`代码在这里非常好用，但你可能需要添加`navigationBarBackButtonHidden()`修饰符，这样用户就必须明确选择“取消”。）
2. 尝试修改第7个项目，让用户可以在导航标题中编辑支出项名称，而不是在单独的文本框中编辑。你更喜欢哪种方式？
3. 回到第8个项目（Moonshot），将其升级为使用`NavigationLink(value:)`。这意味着需要添加`Hashable`协议遵循，并且要仔细思考如何使用`navigationDestination()`。



## 【练习题】导航

问题1/12：以下哪些陈述是正确的？

- **选项1**：结构体要与`NavigationLink`配合使用，必须遵循`Hashable`协议。
- **选项2**：结构体要与`NavigationLink`配合使用，必须遵循`Codable`协议。

问题2/12：以下哪些陈述是正确的？

- **选项1**：要指定工具栏按钮的位置，我们需要使用`ToolbarItem`或`ToolbarItemGroup`。
- **选项2**：当用户导航到详情页面时，返回（Back）按钮必须始终可见。

问题3/12：以下哪些陈述是正确的？

- **选项1**：在列表行（list rows）中使用`NavigationLink`时，SwiftUI会自动在 trailing 边缘添加展开箭头（disclosure chevrons）。
- **选项2**：用户始终可以编辑你的导航标题。

问题4/12：以下哪些陈述是正确的？

- **选项1**：我们可以使用`NavigationLink`或工作表（sheets），但不能两者同时使用。
- **选项2**：`NavigationPath`是跟踪包含多种不同数据类型的路径的最佳方式

问题5/12：以下哪些陈述是正确的？

- **选项1**：`@Binding`属性包装器允许我们与另一个视图共享`@State`属性。
- **选项2**：你应该始终为工具栏按钮指定确切的位置。

问题6/12：以下哪些陈述是正确的？

- **选项1**：隐藏导航栏会禁用向导航栈中推入视图（pushing views onto the stack）的功能。
- **选项2**：如果结构体的所有属性都遵循`Hashable`协议，Swift可以让该结构体自动遵循`Hashable`协议。

问题7/12：以下哪些陈述是正确的？

- **选项1**：我们可以使用`.toolbar(.hidden, for: .navigationBar)`来隐藏导航栏。
- **选项2**：使用多个`navigationDestination()`修饰符是个糟糕的主意。

问题8/12：以下哪些陈述是正确的？

- **选项1**：将导航路径绑定到某个状态时，我们可以使用`didSet`属性观察器来检测路径的变化。
- **选项2**：将值绑定到`NavigationStack`的路径时，该值必须放在一个单独的类中。

问题9/12：以下哪些陈述是正确的？

- **选项1**：如果我们使用`NavigationPath`，就无法保存用户当前的导航路径。
- **选项2**：只有当导航栏处于`.inline`显示模式时，才能启用用户可编辑的导航标题。

问题10/12：以下哪些陈述是正确的？

- **选项1**：可以使用`toolbarColorScheme()`修饰符调整`NavigationStack`中标题文本的颜色。
- **选项2**：如果需要返回到`NavigationStack`的根视图，我们需要调用它的`popToRootView()`方法。

问题11/12：以下哪些陈述是正确的？

- **选项1**：SwiftUI允许我们自定义导航栏的背景颜色。
- **选项2**：每个`NavigationLink`都必须有标题文本。

问题12/12：以下哪些陈述是正确的？

- **选项1**：SwiftUI既可以导航到自定义视图，也可以导航到`Text`和`Color`等内置视图。
- **选项2**：尽可能隐藏导航栏是个好主意。