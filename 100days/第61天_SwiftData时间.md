# 第61天 SwiftData 时间

如果我之前告诉你，你的任务是开发一个应用，要求从网络获取数据、将其解码为原生Swift类型，然后使用导航栈进行展示——哦，对了，整个过程还得用SwiftData来驱动……坦白说，你很可能会对这个任务望而却步。

所以，我换了个方式：昨天已经让你完成了这个应用的基础部分，确保你理解JSON数据结构、正确实现了Codable支持、梳理好了UI设计思路等等。

而**今天**，我要做一件在任何实际项目中都难免会发生的事：给这个项目的范围增加一个新的功能需求。这种情况有时被称为“范围蔓延”，几乎在你参与的每一个项目中都可能遇到。但这并不意味着提前规划没有意义——就像温斯顿·丘吉尔说过的：“制定计划的人比不制定计划的人做得更好，即便他们很少能完全按计划行事。”

所以，我们不会严格按原计划进行；我们要新增一个重要功能，这个功能会迫使你重新思考之前构建应用的方式，有望让你反思代码的结构设计，同时还能让你练习一项如今必须熟练掌握的技术：SwiftData。

没错，你今天的任务就是扩展你的应用，使其支持SwiftData。你的上司刚刚发邮件说，这个应用整体不错，但希望在JSON数据下载完成后，应用能**支持离线使用**。这意味着你需要用SwiftData存储下载到的信息，然后通过SwiftData模型来展示你之前设计的视图——数据只需获取一次即可。

最终呈现的效果，理应和我一开始就把完整任务交给你所达成的效果一致。但像这样把任务拆分成两部分来完成，希望能让它看起来更容易实现，同时也能让你有机会思考：自己的代码结构是否足够灵活，能否应对后续的需求变更。



## 重要提示：请务必阅读！

**这是一项有难度的挑战。** 下面我会给一个小提示，有些人可能会想：“提示？哈！我不需要提示，我自己能搞定！”但今天请破例听一下这个提示，因为它能帮你节省好几个小时的麻烦。

提示如下：你需要将`User`和`Friend`结构体改成遵循`Codable`协议的`@Model`类。要实现这一点，就需要自定义Codable协议的实现：包括一个从`Decoder`初始化的构造器，以及一个`encode(to:)`方法。

如果已经忘记该如何操作，可以重新阅读最近一个里程碑的【重点内容】总结，尤其是“完全自定义Codable实现”那一部分。

提示就这些！再次强调，这是一项有难度的挑战，所以当你觉得困难时，不必感到沮丧。慢慢来，一步一步解决问题就好。

祝你好运！